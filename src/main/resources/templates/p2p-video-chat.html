<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>랜덤 화상채팅</title>
    <link rel="stylesheet" href="/css/chat-style.css">
    <!--    <script src="/js/common-chat.js"></script>-->
    <!--    <script src="/js/random-video-chat.js" defer></script>-->
</head>
<body>
<h1>랜덤 화상채팅</h1>
<button id="startRandomChat">랜덤 채팅 시작</button>

<div id="loadingMessage" style="display: none;">
    <p>상대를 검색중입니다...</p>
    <div class="loader"></div> <!-- 로딩 아이콘 -->
</div>

<div id="chatControls" style="display: none;">
    <button id="disconnectChat">연결 끊기</button>
    <button id="findAnother">다른 상대 찾기</button>
</div>

<div class="container">
    <video id="localVideo" autoplay playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
    <div id="chatBox"></div>
</div>

<input type="text" id="messageInput" placeholder="메시지를 입력하세요">
<button id="sendMessage">전송</button>

<script>
    let signalingServer;
    let localStream;
    let remoteStream;
    let peerConnection;
    let pendingCandidates = [];

    const config = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }
        ]
    };

    let processedOffers = new Set();
    let processedAnswers = new Set();
    let processedCandidates = new Set();

    document.addEventListener('DOMContentLoaded', function() {
        const chatControlBox = document.getElementById('chatControls');
        const disconnectButton = document.getElementById('disconnectChat');
        const findAnotherButton = document.getElementById('findAnother');
        const startRandomChatButton = document.getElementById('startRandomChat');
        const loadingMessage = document.getElementById('loadingMessage');

        startRandomChatButton.onclick = function() {
            startRandomChatButton.style.display = 'none';
            loadingMessage.style.display = 'block';
            startVideoChat();
        };

        disconnectButton.onclick = function() {
            disconnectChat();
        };

        findAnotherButton.onclick = function() {
            disconnectChat();
            resetForNewChat();
        };

        function resetForNewChat() {
            chatControlBox.style.display = 'none';
            startRandomChatButton.style.display = 'block';
        }

        function disconnectChat() {
            if (signalingServer) {
                signalingServer.close();
                signalingServer = null;
            }
            cleanupVideoChat();
            resetForNewChat();
        }

        function startVideoChat() {
            // signalingServer 초기화 전에 peerConnection을 초기화
            initializePeerConnection();

            const signalingServerUrl = 'wss://1.232.89.187:8443/ws/p2p-video-chat';

            if (signalingServer) {
                signalingServer.close();  // 기존 연결이 있으면 종료
                signalingServer = null;
            }

            signalingServer = new WebSocket(signalingServerUrl);

            const localVideo = document.getElementById('localVideo');
            const remoteVideo = document.getElementById('remoteVideo');
            const chatBox = document.getElementById('chatBox');
            const messageInput = document.getElementById('messageInput');
            const sendMessageButton = document.getElementById('sendMessage');

            signalingServer.onopen = () => {
                console.log("랜덤채팅 대기열에 추가되었습니다.");
                signalingServer.send(JSON.stringify({ type: 'random' })); // 대기열에 추가 요청
            };

            signalingServer.onmessage = message => {
                const data = JSON.parse(message.data);
                switch (data.type) {
                    case 'match':
                        setTimeout(() => {
                            alert(data.message);
                            loadingMessage.style.display = 'none';
                            chatControlBox.style.display = 'block';
                            initializePeerConnection(localVideo, remoteVideo, signalingServerUrl);
                        }, 2000);
                        break;
                    case 'offer':
                        handleOffer(data.offer);
                        break;
                    case 'answer':
                        handleAnswer(data.answer);
                        break;
                    case 'candidate':
                        handleCandidate(data.candidate);
                        break;
                    case 'chat':
                        chatBox.innerHTML += `<div>상대방: ${data.message}</div>`;
                        chatBox.scrollTop = chatBox.scrollHeight;
                        break;
                }
            };

            sendMessageButton.onclick = () => {
                const message = messageInput.value;
                if (message) {
                    signalingServer.send(JSON.stringify({ type: 'chat', message: message }));
                    chatBox.innerHTML += `<div>나: ${message}</div>`;
                    chatBox.scrollTop = chatBox.scrollHeight;
                    messageInput.value = '';
                }
            };

            messageInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    sendMessageButton.click();
                }
            });
        }

        function initializePeerConnection(localVideo, remoteVideo, signalingServerUrl) {
            navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                .then(stream => {
                    localVideo.srcObject = stream;
                    localStream = stream;

                    peerConnection = new RTCPeerConnection(config);
                    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

                    peerConnection.onicecandidate = event => {
                        if (event.candidate) {
                            signalingServer.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));
                        }
                    };

                    peerConnection.ontrack = event => {
                        if (!remoteStream) {
                            remoteStream = new MediaStream();
                            remoteVideo.srcObject = remoteStream;
                        }
                        remoteStream.addTrack(event.track);
                    };

                    return peerConnection.createOffer();
                })
                .then(offer => {
                    return peerConnection.setLocalDescription(offer);
                })
                .then(() => {
                    signalingServer.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription }));
                })
                .catch(error => {
                    console.error("Error in startVideoChat:", error);
                });
        }

        function handleOffer(offer) {
            if (peerConnection.signalingState !== "stable") {
                console.warn("잘못된 상태에서 offer가 수신되었습니다. 무시합니다.");
                return;
            }
            if (!processedOffers.has(offer.sdp)) {
                processedOffers.add(offer.sdp);
                peerConnection.setRemoteDescription(new RTCSessionDescription(offer))
                    .then(() => {
                        return peerConnection.createAnswer();
                    })
                    .then(answer => {
                        return peerConnection.setLocalDescription(answer);
                    })
                    .then(() => {
                        signalingServer.send(JSON.stringify({ type: 'answer', answer: peerConnection.localDescription }));
                    })
                    .catch(error => {
                        console.error("Offer 처리 중 오류: ", error);
                    });
            }
        }

        function handleAnswer(answer) {
            if (peerConnection.signalingState !== "have-local-offer") {
                console.warn("잘못된 상태에서 answer가 수신되었습니다.");
                return;
            }
            if (!processedAnswers.has(answer.sdp)) {
                processedAnswers.add(answer.sdp);
                peerConnection.setRemoteDescription(new RTCSessionDescription(answer))
                    .catch(error => {
                        console.error("Answer 처리 중 오류: ", error);
                    });
            }
        }

        function handleCandidate(candidate) {
            if (!processedCandidates.has(candidate.candidate)) {
                processedCandidates.add(candidate.candidate);
                if (peerConnection.remoteDescription && peerConnection.remoteDescription.type) {
                    peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
                        .then(() => {
                            console.log("ICE 후보 추가 성공:", candidate);
                        })
                        .catch(error => {
                            console.error("ICE 후보 추가 중 오류:", error);
                        });
                } else {
                    pendingCandidates.push(candidate);
                    console.warn("ICE 후보를 대기 중입니다: 원격 설명이 설정되지 않음");
                }
            }
        }

        function cleanupVideoChat() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            const localVideo = document.getElementById('localVideo');
            const remoteVideo = document.getElementById('remoteVideo');
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
        }
    });
</script>
</body>
</html>